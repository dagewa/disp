\name{pxIntegrate}
\alias{pxIntegrate}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
%%  ~~function to do ... ~~
}
\description{
%%  ~~ A concise (1-5 lines) description of what the function does. ~~
}
\usage{
pxIntegrate(imageMatrix, type = "mosflm", NX, NY, NRX, NRY, NC, xPx = ceiling(NX/2), yPx = ceiling(NY/2), bias = processing$newBias, gain = NULL, profile = NULL, corArray = NULL, VOMimage = NULL, covArray = NULL, Mobs = NULL, makeProfile = FALSE, messages = TRUE)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{imageMatrix}{
%%     ~~Describe \code{imageMatrix} here~~
}
  \item{type}{
%%     ~~Describe \code{type} here~~
}
  \item{NX}{
%%     ~~Describe \code{NX} here~~
}
  \item{NY}{
%%     ~~Describe \code{NY} here~~
}
  \item{NRX}{
%%     ~~Describe \code{NRX} here~~
}
  \item{NRY}{
%%     ~~Describe \code{NRY} here~~
}
  \item{NC}{
%%     ~~Describe \code{NC} here~~
}
  \item{xPx}{
%%     ~~Describe \code{xPx} here~~
}
  \item{yPx}{
%%     ~~Describe \code{yPx} here~~
}
  \item{bias}{
%%     ~~Describe \code{bias} here~~
}
  \item{gain}{
%%     ~~Describe \code{gain} here~~
}
  \item{profile}{
%%     ~~Describe \code{profile} here~~
}
  \item{corArray}{
%%     ~~Describe \code{corArray} here~~
}
  \item{VOMimage}{
%%     ~~Describe \code{VOMimage} here~~
}
  \item{covArray}{
%%     ~~Describe \code{covArray} here~~
}
  \item{Mobs}{
%%     ~~Describe \code{Mobs} here~~
}
  \item{makeProfile}{
%%     ~~Describe \code{makeProfile} here~~
}
  \item{messages}{
%%     ~~Describe \code{messages} here~~
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
%%  ~~who you are~~
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (imageMatrix, type = "mosflm", NX, NY, NRX, NRY, NC, 
    xPx = ceiling(NX/2), yPx = ceiling(NY/2), bias = processing$newBias, 
    gain = NULL, profile = NULL, corArray = NULL, VOMimage = NULL, 
    covArray = NULL, Mobs = NULL, makeProfile = FALSE, messages = TRUE) 
{
    if (length(dim(imageMatrix)) != 2) 
        stop("pxIntegrate: the supplied imageMatrix is not a 2D matrix")
    if (typeof(bias) == "NULL") 
        stop("pxIntegrate: the bias has not been properly set. Check the 'processing' list")
    stopifnot(length(type) == 1, length(NX) == 1, length(NY) == 
        1, length(NRX) == 1, length(NRY) == 1, length(NC) == 
        1, length(xPx) == 1, length(yPx) == 1, length(bias) == 
        1)
    if (typeof(profile) != "NULL") {
        if (ncol(profile) != NY) 
            stop("pxIntegrate: the profile does not match NY")
        if (nrow(profile) != NX) 
            stop("pxIntegrate: the profile does not match NX")
    }
    stopifnot(NX\%\%2 == 1, NY\%\%2 == 1)
    xSide <- floor(NX/2)
    ySide <- floor(NY/2)
    numPix <- NX * NY
    if (is.null(gain)) 
        gain <- detector$phosphorAmplification * detector$transmission * 
            detector$ADCgain
    spotMask <- .makeSpotMask(NX, NY, NRX, NRY, NC)
    backMask <- !spotMask
    nPeak <- length(spotMask[spotMask])
    nBack <- length(spotMask[backMask])
    imageSlice <- imageMatrix[(xPx - xSide):(xPx + xSide), (yPx - 
        ySide):(yPx + ySide)]
    imageSlice <- imageSlice - bias
    backplane <- .background(NX, NY, spotMask, imageSlice)
    peakBack <- sum(backplane[spotMask])
    if (messages) 
        cat("pxIntegrate: after bias subtraction, average determined background level under peak region is", 
            peakBack/nPeak, "\n\n")
    if (makeProfile) 
        return(imageSlice - backplane)
    imageSlicePos <- imageSlice
    imageSlicePos[imageSlicePos < 0] <- 0
    typeCase <- pmatch(type, c("mosflm", "covArray", "corArray", 
        "full"))
    if (is.na(typeCase)) 
        stop("Bad parameter for type")
    if (typeCase == 1) {
        Mobs <- gain * diag(imageSlicePos[1:(NX * NY)])
    }
    if (typeCase == 2) {
        if (typeof(covArray) == "NULL") 
            stop("pxIntegrate: No covArray supplied")
        dummy <- matrix(data = 1, ncol = NY, nrow = NX)
        Mobs <- flatten(dummy, dummy, covArray[(xPx - xSide):(xPx + 
            xSide), (yPx - ySide):(yPx + ySide), , ])
    }
    if (typeCase == 3) {
        if (typeof(corArray) == "NULL") 
            stop("pxIntegrate: No corArray supplied")
        if (typeof(VOMimage) == "NULL") 
            stop("pxIntegrate: No VOMimage supplied to accompany corArray")
        Mobs <- flatten(imageSlicePos, VOMimage[(xPx - xSide):(xPx + 
            xSide), (yPx - ySide):(yPx + ySide)], corArray[(xPx - 
            xSide):(xPx + xSide), (yPx - ySide):(yPx + ySide), 
            , ])
    }
    if (typeCase == 4) {
        if (typeof(Mobs) == "NULL") 
            stop("pxIntegrate: No Mobs array supplied")
    }
    peakTotal <- sum(imageSlice[spotMask])
    Is <- peakTotal - peakBack
    if (messages) 
        cat("pxIntegrate: summation integrated intensity in ADUs is", 
            Is, "\n\n")
    peakMobs <- Mobs
    for (i in seq_along(backMask)) if (backMask[i]) {
        peakMobs[i, ] <- 0
        peakMobs[, i] <- 0
    }
    backMobs <- Mobs
    for (i in seq_along(spotMask)) if (spotMask[i]) {
        backMobs[i, ] <- 0
        backMobs[, i] <- 0
    }
    backSumCov <- sum(backMobs)
    backSumCov <- (nPeak/nBack)^2 * backSumCov
    peakSumCov <- sum(peakMobs)
    varIs <- peakSumCov + backSumCov
    varIsCascade <- NA
    if (typeCase == 1) {
        cascadeFactor <- 1 + (detector$phosphorNoise/detector$phosphorAmplification)^2 + 
            (1 - detector$transmission)/(detector$phosphorAmplification * 
                detector$transmission)
        MobsCascade <- Mobs * cascadeFactor
        pixelNoise <- (detector$readNoise)^2 + 1/(12 * detector$ADCgain^2)
        pixelNoise <- pixelNoise/(detector$phosphorAmplification * 
            detector$transmission)^2
        diag(MobsCascade) <- diag(MobsCascade) + pixelNoise
        peakMobsCascade <- MobsCascade
        for (i in seq_along(backMask)) if (backMask[i]) {
            peakMobsCascade[i, ] <- 0
            peakMobsCascade[, i] <- 0
        }
        backMobsCascade <- MobsCascade
        for (i in seq_along(spotMask)) if (spotMask[i]) {
            backMobsCascade[i, ] <- 0
            backMobsCascade[, i] <- 0
        }
        backSumCovCascade <- sum(backMobsCascade)
        backSumCovCascade <- (nPeak/nBack)^2 * backSumCovCascade
        peakSumCovCascade <- sum(peakMobsCascade)
        varIsCascade <- peakSumCovCascade + backSumCovCascade
    }
    if (messages) {
        cat("pxIntegrate: variance of peak in ADU^2 using", type, 
            "method is", peakSumCov, "\n")
        cat("pxIntegrate: variance of background under peak in ADU^2 using", 
            type, "method is", backSumCov, "\n")
        cat("pxIntegrate: total variance in ADU^2 using", type, 
            "method is", varIs, "\n\n")
        if (typeCase == 1) {
            cat("pxIntegrate: Poisson excess 'cascadeFactor' for this detector is", 
                cascadeFactor, "\n")
            cat("pxIntegrate: read and digitisation noise contribution to variance per pixel is", 
                pixelNoise, "ADU^2\n")
            cat("pxIntegrate: variance of peak in ADU^2 inflating the error due to the cascade and pixel noise model is", 
                peakSumCovCascade, "\n")
            cat("pxIntegrate: variance of background under peak in ADU^2 inflating the error due to the cascade and pixel noise model is", 
                backSumCovCascade, "\n")
            cat("pxIntegrate: total variance in ADU^2 inflating the error due to the cascade and pixel noise model is", 
                varIsCascade, "\n\n")
        }
    }
    Ip <- NA
    varIp <- NA
    if (typeof(profile) != "NULL") {
        if (typeCase == 1) {
            profSum <- sum(profile)
            J <- Is/profSum
            varImage <- (backplane + J * profile)
            if (min(varImage) < 0) {
                cat("pxIntegrate WARNING: the background appears to be very low leading to some negative", 
                  "values in the calculation of pixel variance for profile fitting, assuming Poisson stats.\n")
                print.noquote(paste("min(varImage) =", min(varImage)))
            }
            index <- matrix(data = seq(1, numPix), ncol = NY, 
                nrow = NX)
            Mobs <- matrix(data = 0, ncol = numPix, nrow = numPix)
            for (j in 1:NY) for (i in 1:NX) {
                pixelij <- index[i, j]
                Mobs[pixelij, pixelij] <- varImage[i, j]
            }
        }
        MobsInv <- solve(Mobs)
        Obs <- imageSlice
        dim(Obs) <- NULL
        midX <- xSide + 1
        midY <- ySide + 1
        p <- rep(1:NX, NY)
        dim(p) <- c(NX, NY)
        p <- p - midX
        q <- rep(1:NY, NX)
        dim(q) <- c(NY, NX)
        q <- t(q)
        q <- q - midY
        A <- cbind(profile[1:numPix], p[1:numPix], q[1:numPix], 
            rep(1, numPix))
        B <- t(A) \%*\% MobsInv \%*\% A
        D <- t(A) \%*\% MobsInv \%*\% Obs
        Binv <- solve(B)
        Xhat <- Binv \%*\% D
        K <- Xhat[1]
        if (messages) 
            cat("pxIntegrate: Best estimate of parameters vector Xhat (K, a, b, c) =", 
                Xhat[1], Xhat[2], Xhat[3], Xhat[4], "\n")
        Ip <- K * sum(profile)
        Kv <- 1
        if (typeCase == 1) {
            V <- Obs - A \%*\% Xhat
            Kv <- t(V) \%*\% MobsInv \%*\% V/(numPix - 4)
            dim(Kv) <- NULL
            if (messages) 
                cat("pxIntegrate: Kv scale factor = ", Kv, "\n")
        }
        Mx <- Kv * Binv
        varIp <- Mx[1, 1] * sum(profile)^2
        if (messages) {
            cat("pxIntegrate: profile fitting integrated intensity in ADU is =", 
                Ip, "\n\n")
            cat("pxIntegrate: profile fitting variance estimate in ADU^2 is =", 
                varIp, "\n")
        }
    }
    if (messages) 
        cat("pxIntegrate: return values: Is, varIs, varIsCascade, Ip, varIp\n")
    return(c(Is, varIs, varIsCascade, Ip, varIp))
  }
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ ~kwd1 }
\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
